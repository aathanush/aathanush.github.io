import MarkdownIt from 'markdown-it';

function checkValueIsEmpty(value) {
    const nextValue = typeof value === 'string' ? value.trim() : value;
    return ['', NaN, null, undefined].includes(nextValue);
}
function tuiCleanObject(object) {
    return JSON.parse(JSON.stringify(object, (_key, value) => checkValueIsEmpty(value) ? undefined : value));
}

function tuiCoerceValueIsTrue(value) {
    return value?.toString() === 'true';
}

function isEmptyParamValue(value) {
    return ['NaN', 'null', 'undefined'].includes(value);
}
function isBooleanParamValue(value) {
    return value === 'true' || value === 'false';
}
function isNumberParamValue(value) {
    return !!value.trim() && !Number.isNaN(Number(value)) && !value.startsWith('+');
}
function isPossibleArray(value) {
    return value.startsWith('[') && value.endsWith(']');
}
function isPossibleObject(value) {
    return value.startsWith('{') && value.endsWith('}');
}
function tuiCoerceValue(value) {
    const prepared = String(value).trim();
    if (isEmptyParamValue(prepared)) {
        return null;
    }
    if (isBooleanParamValue(prepared)) {
        return String(prepared) === 'true';
    }
    if (isNumberParamValue(prepared)) {
        return Number(prepared);
    }
    if (prepared === '%') {
        // https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/decodeURIComponent#exceptions
        return prepared;
    }
    const decodedValue = decodeURIComponent(prepared);
    try {
        return isPossibleArray(decodedValue) || isPossibleObject(decodedValue)
            ? JSON.parse(decodedValue)
            : decodedValue;
    }
    catch {
        return decodedValue;
    }
}

function inspectArray(array, depth) {
    if (depth === 0) {
        return '[…]';
    }
    let result = '';
    let first = true;
    for (let index = 0; index < array.length; index++) {
        if (first) {
            first = false;
        }
        else {
            result += ', ';
        }
        result += index in array ? tuiInspectAny(array[index], depth - 1) : 'empty';
    }
    return `[${result}]`;
}
function inspectObject(object, depth) {
    if (depth === 0) {
        return '{…}';
    }
    let result = '';
    let first = true;
    for (const key in object) {
        if (!object.hasOwnProperty(key)) {
            continue;
        }
        if (first) {
            first = false;
        }
        else {
            result += ', ';
        }
        result += `${key}: ${tuiInspectAny(object[key], depth - 1)}`;
    }
    return `{${result}}`;
}
/**
 * Returns readable JS entity
 * @param data
 * @param depth
 * @return readable JS entity
 */
function tuiInspectAny(data, depth) {
    if (data === null) {
        return 'null';
    }
    switch (typeof data) {
        case 'boolean':
        case 'function':
        case 'number':
        case 'undefined':
            return String(data);
        case 'string':
            return `'${data}'`;
        default:
            break;
    }
    if (data instanceof RegExp) {
        return String(data);
    }
    if (Array.isArray(data)) {
        return inspectArray(data, depth);
    }
    return inspectObject(data, depth);
}

function tuiIsRoutePageGroup(page) {
    return 'subPages' in page;
}

function tuiTryParseMarkdownCodeBlock(text = '') {
    const tokens = new MarkdownIt().parse(text, {});
    const result = tokens
        .filter(({ tag, type }) => tag === 'code' && type === 'fence')
        .map(({ content }) => content.trim());
    return result.length ? result : [text];
}

function tuiProvideRoutePageTab({ path, title, loadComponent, loadChildren, } = {}) {
    return {
        path: path?.replace(/^\//, ''),
        loadComponent,
        loadChildren,
        data: { title },
        ...(!loadChildren && path !== ''
            ? { children: [{ path: ':tab', loadComponent }] }
            : {}),
    };
}

async function tuiRawLoad(content) {
    return content instanceof Promise ? (await content).default : content;
}

async function tuiRawLoadRecord(example) {
    const processedContent = {};
    for (const [key, content] of Object.entries(example)) {
        if (content) {
            processedContent[key] = await tuiRawLoad(content);
        }
    }
    return processedContent;
}

function tuiSortPages(pages, excludeSections = new Set()) {
    const sections = Array.from(new Set(pages.map((page) => page.section)));
    const sortedPages = pages.slice().sort((a, b) => {
        if (excludeSections.has(a.section ?? '') ||
            excludeSections.has(b.section ?? '')) {
            return 0;
        }
        const aSectionIndex = sections.indexOf(a.section);
        const bSectionIndex = sections.indexOf(b.section);
        if (aSectionIndex !== bSectionIndex) {
            return aSectionIndex - bSectionIndex;
        }
        if (a.title > b.title) {
            return 1;
        }
        return a.title.localeCompare(b.title);
    });
    return sortedPages.map((page) => tuiIsRoutePageGroup(page)
        ? {
            ...page,
            subPages: tuiSortPages(page.subPages, excludeSections),
        }
        : page);
}

function assertTitle(page, map) {
    if (map.has(page.title) && map.get(page.title)?.route !== page.route) {
        console.error('Title for page should be unique for prevent inconsistent page names', page, '<== Collisions between ==>', map.get(page.title));
    }
}
function tuiToFlatMapPages(pages) {
    const map = new Map();
    pages.forEach((page) => {
        if ('subPages' in page) {
            page.subPages.forEach((subPage) => {
                ngDevMode && assertTitle(subPage, map);
                map.set(subPage.title, subPage);
            });
        }
        else {
            ngDevMode && assertTitle(page, map);
            map.set(page.title, page);
        }
    });
    return map;
}

const MAP = {
    а: 'f',
    б: ',',
    в: 'd',
    г: 'u',
    д: 'l',
    е: 't',
    ё: '`',
    ж: ';',
    з: 'p',
    и: 'b',
    й: 'q',
    к: 'r',
    л: 'k',
    м: 'v',
    н: 'y',
    о: 'j',
    п: 'g',
    р: 'h',
    с: 'c',
    т: 'n',
    у: 'e',
    ф: 'a',
    х: '[',
    ц: 'w',
    ч: 'x',
    ш: 'i',
    щ: 'o',
    ъ: ']',
    ы: 's',
    ь: 'm',
    ю: '.',
    я: 'z',
};
/**
 * Translates text mistakenly typed in the Russian layout into English
 * @param string string with Russian layout characters
 * @return string with English layout characters
 */
function tuiTransliterateKeyboardLayout(string) {
    let newStr = '';
    for (let i = 0; i < string.length; i++) {
        newStr += string.charAt(i) in MAP ? MAP[string.charAt(i)] : string.charAt(i);
    }
    return newStr;
}

function tuiTypeReferenceParser(types) {
    const generics = types.match(/<([^>]+)>/g);
    const escaped = generics
        ? generics
            .reduce((result, current) => result.replace(current, current.replaceAll('|', '&')), types)
            .split('|')
            .map((item) => item.trim())
        : types.split('|').map((item) => item.trim());
    return escaped.reduce((result, type) => {
        let extracted = type.trim().replaceAll('readonly ', '').replaceAll('[]', '');
        extracted =
            /ReadonlyArray<([^>]+)>/.exec(extracted)?.[1]?.split('&')?.[0] ?? extracted;
        extracted = /\[([^\]]+)\]/.exec(extracted)?.[1]?.split(',')?.[0] ?? extracted;
        extracted = (extracted.split('<')?.[0] ?? extracted)?.trim() ?? '';
        extracted = Number.isNaN(parseFloat(extracted)) ? extracted : 'number';
        extracted = /^'(.+)'$|^"(.+)"$|^`(.+)`$/.test(extracted) ? 'string' : extracted;
        extracted = extracted.length === 1 ? 'unknown' : extracted;
        return result.concat({ type: type.replaceAll('&', '|'), extracted });
    }, []);
}

/**
 * Generated bundle index. Do not edit.
 */

export { tuiCleanObject, tuiCoerceValue, tuiCoerceValueIsTrue, tuiInspectAny, tuiIsRoutePageGroup, tuiProvideRoutePageTab, tuiRawLoad, tuiRawLoadRecord, tuiSortPages, tuiToFlatMapPages, tuiTransliterateKeyboardLayout, tuiTryParseMarkdownCodeBlock, tuiTypeReferenceParser };
//# sourceMappingURL=taiga-ui-addon-doc-utils.mjs.map
