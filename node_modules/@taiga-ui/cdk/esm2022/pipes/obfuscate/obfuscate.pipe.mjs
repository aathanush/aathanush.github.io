import { inject, Pipe } from '@angular/core';
import { TUI_OBFUSCATE_OPTIONS } from './obfuscate.options';
import * as i0 from "@angular/core";
class TuiObfuscatePipe {
    constructor() {
        this.option = inject(TUI_OBFUSCATE_OPTIONS);
    }
    /**
     * Transforms the input value by obfuscating it according to the specified recipe or symbol.
     *
     * @param value The value to be obfuscated should be a string.
     * @param recipe The name of the recipe to use for obfuscation or a single character symbol for custom obfuscation.
     * @returns The obfuscated string.
     * @throws Will throw an error if the specified recipe is not found.
     */
    transform(value, recipe = '') {
        if (!value) {
            return value;
        }
        if (!recipe) {
            return this.option.default(value);
        }
        const obfuscate = this.option.recipes[recipe];
        if (obfuscate) {
            return obfuscate(value);
        }
        if (recipe.length === 1) {
            return this.option.default(value, recipe[0]);
        }
        const availableRecipes = Object.keys(this.option.recipes).sort();
        throw new Error(`Obfuscate recipe "${recipe}" not found. Available recipes: [${availableRecipes}]`);
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: TuiObfuscatePipe, deps: [], target: i0.ɵɵFactoryTarget.Pipe }); }
    static { this.ɵpipe = i0.ɵɵngDeclarePipe({ minVersion: "14.0.0", version: "16.2.12", ngImport: i0, type: TuiObfuscatePipe, isStandalone: true, name: "tuiObfuscate" }); }
}
export { TuiObfuscatePipe };
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: TuiObfuscatePipe, decorators: [{
            type: Pipe,
            args: [{
                    standalone: true,
                    name: 'tuiObfuscate',
                }]
        }] });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoib2JmdXNjYXRlLnBpcGUuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi9wcm9qZWN0cy9jZGsvcGlwZXMvb2JmdXNjYXRlL29iZnVzY2F0ZS5waXBlLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUNBLE9BQU8sRUFBQyxNQUFNLEVBQUUsSUFBSSxFQUFDLE1BQU0sZUFBZSxDQUFDO0FBRTNDLE9BQU8sRUFBQyxxQkFBcUIsRUFBQyxNQUFNLHFCQUFxQixDQUFDOztBQUUxRCxNQUlhLGdCQUFnQjtJQUo3QjtRQUtxQixXQUFNLEdBQUcsTUFBTSxDQUFDLHFCQUFxQixDQUFDLENBQUM7S0FtQzNEO0lBakNHOzs7Ozs7O09BT0c7SUFDSSxTQUFTLENBQUMsS0FBYSxFQUFFLE1BQU0sR0FBRyxFQUFFO1FBQ3ZDLElBQUksQ0FBQyxLQUFLLEVBQUU7WUFDUixPQUFPLEtBQUssQ0FBQztTQUNoQjtRQUVELElBQUksQ0FBQyxNQUFNLEVBQUU7WUFDVCxPQUFPLElBQUksQ0FBQyxNQUFNLENBQUMsT0FBTyxDQUFDLEtBQUssQ0FBQyxDQUFDO1NBQ3JDO1FBRUQsTUFBTSxTQUFTLEdBQUcsSUFBSSxDQUFDLE1BQU0sQ0FBQyxPQUFPLENBQUMsTUFBTSxDQUFDLENBQUM7UUFFOUMsSUFBSSxTQUFTLEVBQUU7WUFDWCxPQUFPLFNBQVMsQ0FBQyxLQUFLLENBQUMsQ0FBQztTQUMzQjtRQUVELElBQUksTUFBTSxDQUFDLE1BQU0sS0FBSyxDQUFDLEVBQUU7WUFDckIsT0FBTyxJQUFJLENBQUMsTUFBTSxDQUFDLE9BQU8sQ0FBQyxLQUFLLEVBQUUsTUFBTSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7U0FDaEQ7UUFFRCxNQUFNLGdCQUFnQixHQUFHLE1BQU0sQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxPQUFPLENBQUMsQ0FBQyxJQUFJLEVBQUUsQ0FBQztRQUVqRSxNQUFNLElBQUksS0FBSyxDQUNYLHFCQUFxQixNQUFNLG9DQUFvQyxnQkFBZ0IsR0FBRyxDQUNyRixDQUFDO0lBQ04sQ0FBQzsrR0FuQ1EsZ0JBQWdCOzZHQUFoQixnQkFBZ0I7O1NBQWhCLGdCQUFnQjs0RkFBaEIsZ0JBQWdCO2tCQUo1QixJQUFJO21CQUFDO29CQUNGLFVBQVUsRUFBRSxJQUFJO29CQUNoQixJQUFJLEVBQUUsY0FBYztpQkFDdkIiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgdHlwZSB7UGlwZVRyYW5zZm9ybX0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQge2luamVjdCwgUGlwZX0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5cbmltcG9ydCB7VFVJX09CRlVTQ0FURV9PUFRJT05TfSBmcm9tICcuL29iZnVzY2F0ZS5vcHRpb25zJztcblxuQFBpcGUoe1xuICAgIHN0YW5kYWxvbmU6IHRydWUsXG4gICAgbmFtZTogJ3R1aU9iZnVzY2F0ZScsXG59KVxuZXhwb3J0IGNsYXNzIFR1aU9iZnVzY2F0ZVBpcGUgaW1wbGVtZW50cyBQaXBlVHJhbnNmb3JtIHtcbiAgICBwcml2YXRlIHJlYWRvbmx5IG9wdGlvbiA9IGluamVjdChUVUlfT0JGVVNDQVRFX09QVElPTlMpO1xuXG4gICAgLyoqXG4gICAgICogVHJhbnNmb3JtcyB0aGUgaW5wdXQgdmFsdWUgYnkgb2JmdXNjYXRpbmcgaXQgYWNjb3JkaW5nIHRvIHRoZSBzcGVjaWZpZWQgcmVjaXBlIG9yIHN5bWJvbC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB2YWx1ZSBUaGUgdmFsdWUgdG8gYmUgb2JmdXNjYXRlZCBzaG91bGQgYmUgYSBzdHJpbmcuXG4gICAgICogQHBhcmFtIHJlY2lwZSBUaGUgbmFtZSBvZiB0aGUgcmVjaXBlIHRvIHVzZSBmb3Igb2JmdXNjYXRpb24gb3IgYSBzaW5nbGUgY2hhcmFjdGVyIHN5bWJvbCBmb3IgY3VzdG9tIG9iZnVzY2F0aW9uLlxuICAgICAqIEByZXR1cm5zIFRoZSBvYmZ1c2NhdGVkIHN0cmluZy5cbiAgICAgKiBAdGhyb3dzIFdpbGwgdGhyb3cgYW4gZXJyb3IgaWYgdGhlIHNwZWNpZmllZCByZWNpcGUgaXMgbm90IGZvdW5kLlxuICAgICAqL1xuICAgIHB1YmxpYyB0cmFuc2Zvcm0odmFsdWU6IHN0cmluZywgcmVjaXBlID0gJycpOiBzdHJpbmcge1xuICAgICAgICBpZiAoIXZhbHVlKSB7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXJlY2lwZSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMub3B0aW9uLmRlZmF1bHQodmFsdWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3Qgb2JmdXNjYXRlID0gdGhpcy5vcHRpb24ucmVjaXBlc1tyZWNpcGVdO1xuXG4gICAgICAgIGlmIChvYmZ1c2NhdGUpIHtcbiAgICAgICAgICAgIHJldHVybiBvYmZ1c2NhdGUodmFsdWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHJlY2lwZS5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm9wdGlvbi5kZWZhdWx0KHZhbHVlLCByZWNpcGVbMF0pO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgYXZhaWxhYmxlUmVjaXBlcyA9IE9iamVjdC5rZXlzKHRoaXMub3B0aW9uLnJlY2lwZXMpLnNvcnQoKTtcblxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICBgT2JmdXNjYXRlIHJlY2lwZSBcIiR7cmVjaXBlfVwiIG5vdCBmb3VuZC4gQXZhaWxhYmxlIHJlY2lwZXM6IFske2F2YWlsYWJsZVJlY2lwZXN9XWAsXG4gICAgICAgICk7XG4gICAgfVxufVxuIl19